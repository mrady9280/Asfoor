@page "/agchat"
@using System.ComponentModel
@using System.Text
@using Microsoft.Agents.AI
@using Microsoft.Agents.AI.AGUI
@using Microsoft.Extensions.AI
@using Microsoft.Extensions.Configuration
@using Microsoft.AspNetCore.Components.Forms
@inject NavigationManager Nav
@inject IConfiguration Configuration
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@implements IDisposable

<PageTitle>AGUI Chat</PageTitle>

<MudContainer MaxWidth="MaxWidth.False" Class="pa-0 ma-0" Style="height: calc(100vh - 64px);">
    <div class="d-flex flex-column mud-paper mud-theme-surface" style="height: 100%;">

        @* Header *@
        <div class="pa-3">
            <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                <MudStack Row="true" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">AGUI Chat</MudText>
                </MudStack>
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudTooltip Text="Switch to Modern Chat">
                        <MudIconButton Icon="@Icons.Material.Filled.Chat" OnClick="@(() => Nav.NavigateTo("/"))" />
                    </MudTooltip>
                    <MudTooltip Text="Reset conversation">
                        <MudIconButton Icon="@Icons.Material.Filled.Refresh" OnClick="@ResetConversationAsync" />
                    </MudTooltip>
                </MudStack>
            </MudStack>
        </div>

        @* Messages area *@
        <div class="pa-4 flex-grow-1" id="chat-messages" style="overflow-y: auto;">
            @if (!messages.Any() && currentResponseMessage == null)
            {
                <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center" Class="h-100">
                    <MudIcon Icon="@Icons.Material.Filled.ChatBubbleOutline" Size="Size.Large" Color="Color.Primary"
                             Style="font-size: 4rem;" />
                    <MudText Typo="Typo.h6" Color="Color.Primary">Start a Conversation</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Secondary">Powered by AG-UI Agents</MudText>
                </MudStack>
            }
            else
            {
                @foreach (var message in messages)
                {
                    <MudStack Row="true"
                              Justify="@(message.Role == ChatRole.User ? Justify.FlexEnd : Justify.FlexStart)"
                              Class="mb-4">
                        @if (message.Role == ChatRole.Assistant)
                        {
                            <MudAvatar Color="Color.Secondary" Size="Size.Medium" Class="mr-2">
                                <MudIcon Icon="@Icons.Material.Filled.SmartToy" />
                            </MudAvatar>
                        }

                        <MudPaper Elevation="2" Class="pa-3" Style="max-width: 70%;">
                            <MudText Typo="Typo.body1" Style="white-space: pre-wrap; word-wrap: break-word;">@message.Text</MudText>

                            @if (attachmentsByMessage.ContainsKey(message))
                            {
                                <MudStack Row="true" Class="mt-2" Style="flex-wrap: wrap;" Spacing="1">
                                    @foreach (var file in attachmentsByMessage[message])
                                    {
                                        <MudChip T="string" Icon="@GetFileIcon(file.ContentType)" Size="Size.Small"
                                                 Variant="Variant.Outlined">
                                            @file.Name (@FormatFileSize(file.Size))
                                        </MudChip>
                                    }
                                </MudStack>
                            }
                        </MudPaper>

                        @if (message.Role == ChatRole.User)
                        {
                            <MudAvatar Color="Color.Primary" Size="Size.Medium" Class="ml-2">
                                <MudIcon Icon="@Icons.Material.Filled.Person" />
                            </MudAvatar>
                        }
                    </MudStack>
                }

                @if (currentResponseMessage != null)
                {
                    <MudStack Row="true" Justify="Justify.FlexStart" Class="mb-4">
                        <MudAvatar Color="Color.Secondary" Size="Size.Medium" Class="mr-2">
                            <MudIcon Icon="@Icons.Material.Filled.SmartToy" />
                        </MudAvatar>
                        <MudPaper Elevation="2" Class="pa-3" Style="max-width: 70%;">
                             @if (!string.IsNullOrEmpty(currentResponseMessage.Text))
                            {
                                <MudText Typo="Typo.body1" Style="white-space: pre-wrap; word-wrap: break-word;">@currentResponseMessage.Text</MudText>
                            }
                            @if (currentResponseMessage.Contents.Count == 0 || (currentResponseMessage.Contents.Count == 1 && string.IsNullOrEmpty(currentResponseMessage.Text)))
                            {
                                <MudProgressCircular Indeterminate="true" Size="Size.Small" Class="ml-2" />
                            }
                        </MudPaper>
                    </MudStack>
                }
            }
        </div>

        @* Input area *@
        <div class="pa-2">
             @if (attachedFiles.Any())
            {
                <MudPaper Outlined="true" Class="mb-2 pa-2">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Style="flex-wrap: wrap;">
                        <MudText Typo="Typo.caption" Style="font-weight: 600;">Attached:</MudText>
                        @foreach (var file in attachedFiles)
                        {
                            <MudChip T="string" Icon="@GetFileIcon(file.ContentType)" Size="Size.Small"
                                     OnClose="() => RemoveFile(file)">
                                @file.Name (@FormatFileSize(file.Size))
                            </MudChip>
                        }
                    </MudStack>
                </MudPaper>
            }
            
            <MudStack Row="true" AlignItems="AlignItems.End" Spacing="1">
                <MudTextField @bind-Value="userInput"
                              Label="Type your message..."
                              Variant="Variant.Outlined"
                              Immediate="true"
                              Lines="1"
                              FullWidth="true"
                              Disabled="@(currentResponseMessage != null)"
                              OnKeyDown="@HandleKeyDown" />

                <MudTooltip Text="Attach files">
                    <MudFileUpload T="IBrowserFile" FilesChanged="HandleFilesSelected" Disabled="@(currentResponseMessage != null)">
                        <ActivatorContent>
                            <MudIconButton Icon="@Icons.Material.Filled.AttachFile" Disabled="@(currentResponseMessage != null)"/>
                        </ActivatorContent>
                    </MudFileUpload>
                </MudTooltip>

                <MudTooltip Text="Send message (Enter)">
                    <span>
                        <MudIconButton Icon="@Icons.Material.Filled.Send"
                                       Color="Color.Primary"
                                       OnClick="@SendMessageAsync"
                                       Disabled="@((string.IsNullOrWhiteSpace(userInput) && !attachedFiles.Any()) || currentResponseMessage != null)" />
                    </span>
                </MudTooltip>
            </MudStack>
        </div>
    </div>
</MudContainer>

@code {
    private const long maxFileSize = 10 * 1024 * 1024; // 10 MB
    private int statefulMessageCount;
    private readonly ChatOptions chatOptions = new();
    private readonly List<ChatMessage> messages = new();
     // Keep track of attachments separately for display purposes if needed, OR relies on ChatMessage contents?
    // ModernChat kept a separate dictionary for display because standard ChatMessage text doesn't show files.
    private Dictionary<ChatMessage, List<FileAttachment>> attachmentsByMessage = new();
    private List<FileAttachment> attachedFiles = new();
    
    private CancellationTokenSource? currentResponseCancellation;
    private ChatMessage? currentResponseMessage;
    private string userInput = "";

    AIAgent? _agent;
    HttpClient? _httpClient;
    AGUIChatClient? _chatClient;
    AgentThread _thread; 

    protected override void OnInitialized()
    {
        statefulMessageCount = 0;
        _httpClient = new HttpClient();
        string apiBaseAddress = Configuration["API_HTTP"] + "/agchat";
        _chatClient = new AGUIChatClient(_httpClient, apiBaseAddress);
        _agent = _chatClient!.CreateAIAgent();
        _thread = _agent.GetNewThread();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (currentResponseMessage != null || firstRender)
        {
            await ScrollToBottom();
        }
    }

     private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendMessageAsync();
        }
    }

    private async Task HandleFilesSelected(IBrowserFile file)
    {
        if (file.Size > maxFileSize)
        {
            Snackbar.Add($"File {file.Name} is too large. Maximum size is 10 MB.", Severity.Warning);
            return;
        }

        var fileAttachment = new FileAttachment
        {
            Name = file.Name,
            Size = file.Size,
            ContentType = file.ContentType,
            BrowserFile = file
        };

        attachedFiles.Add(fileAttachment);
        Snackbar.Add($"Attached {file.Name}", Severity.Success);
        StateHasChanged();
    }

    private void RemoveFile(FileAttachment file)
    {
        attachedFiles.Remove(file);
        StateHasChanged();
    }


    private async Task SendMessageAsync()
    {
        if ((string.IsNullOrWhiteSpace(userInput) && !attachedFiles.Any())) return;

        // Construct the message contet
        var items = new List<AIContent>();
        if (!string.IsNullOrWhiteSpace(userInput)) 
        {
             items.Add(new TextContent(userInput));
        }
        
        // Add attached files as DataContent
        if (attachedFiles.Any())
        {
            foreach (var file in attachedFiles)
            {
                try 
                {
                    await using var stream = file.BrowserFile.OpenReadStream(maxFileSize);
                    using var ms = new MemoryStream();
                    await stream.CopyToAsync(ms);
                    // Use DataContent for generic file data
                    items.Add(new DataContent(ms.ToArray(), file.ContentType));
                }
                catch (Exception ex)
                {
                    Snackbar.Add($"Failed to read file {file.Name}: {ex.Message}", Severity.Error);
                    return; // Stop sending if file read fails
                }
            }
        }

        var userMsg = new ChatMessage(ChatRole.User, items);
        
        // Store attachments for UI display (since DataContent isn't easily rendered as a chip in the loop without logic)
        if (attachedFiles.Any())
        {
            attachmentsByMessage[userMsg] = new List<FileAttachment>(attachedFiles);
        }
        
        userInput = ""; // Clear input immediately
        attachedFiles.Clear();
        await AddUserMessageAsync(userMsg);
    }
    
    private async Task AddUserMessageAsync(ChatMessage userMessage)
    {
        CancelAnyCurrentResponse();
        // Add the user message to the conversation
        messages.Add(userMessage);
        
        // Stream and display a new response from the IChatClient
        var responseText = new TextContent("");
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
        currentResponseCancellation = new();
        StateHasChanged();
        await ScrollToBottom();

        try
        {
            await foreach (AgentRunResponseUpdate update in _agent.RunStreamingAsync(userMessage,_thread))
            {
                foreach (AIContent content in update.Contents)
                {
                    switch (content)
                    {
                        case TextContent textContent:
                            messages.AddMessages(new ChatResponseUpdate(ChatRole.Assistant, [textContent]), filter: c => c is not TextContent);
                            responseText.Text += update.Text;
                            break;
                        case FunctionCallContent functionCallContent:
                            StringBuilder toolCallDetails = new();
                            toolCallDetails.Append($"[Tool Call: {functionCallContent.Name}");
                            if (functionCallContent.Arguments != null && functionCallContent.Arguments.Any())
                            {
                                toolCallDetails.Append($" (Args: {string.Join(",", functionCallContent.Arguments.Select(x => $"[{x.Key} = {x.Value}]"))}");
                            }
                            toolCallDetails.Append("]");
                            // Add as TextContent so it shows up in the chat bubble
                            messages.AddMessages(new ChatResponseUpdate(ChatRole.Assistant, [new TextContent(toolCallDetails.ToString())]), filter: c => c is not TextContent);
                            break;
                            
                        case FunctionResultContent functionResultContent:
                            bool isError = functionResultContent.Exception != null;
                            var y = isError ? $"[Tool Error: {functionResultContent.Exception}]" : $"[Tool Result: {functionResultContent.Result}]";
                             // Add as TextContent
                            messages.AddMessages(new ChatResponseUpdate(ChatRole.Assistant, [new TextContent(y)]), filter: c => c is not TextContent);
                            break;
                            
                        case ErrorContent errorContent:
                            var x = $"[Error: {errorContent.Message}]";
                             // Add as TextContent
                            messages.AddMessages(new ChatResponseUpdate(ChatRole.Assistant, [new TextContent(x)]), filter: c => c is not TextContent);
                            break;
                    }
                }
                StateHasChanged();
                await ScrollToBottom();
            }

            // Store the final response in the conversation
            messages.Add(currentResponseMessage!);
            statefulMessageCount = chatOptions.ConversationId is not null ? messages.Count : 0;
            currentResponseMessage = null;
        }
        catch (Exception ex)
        {
             Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
             StateHasChanged();
             await ScrollToBottom();
        }
    }

    private void CancelAnyCurrentResponse()
    {
        // If a response was cancelled while streaming, include it in the conversation so it's not lost
        if (currentResponseMessage is not null)
        {
            messages.Add(currentResponseMessage);
        }

        currentResponseCancellation?.Cancel();
        currentResponseMessage = null;
    }

    private async Task ResetConversationAsync()
    {
        CancelAnyCurrentResponse();
        messages.Clear();
        chatOptions.ConversationId = null;
        statefulMessageCount = 0;
        userInput = "";
        attachedFiles.Clear(); 
        attachmentsByMessage.Clear();
        StateHasChanged();
    }

     private async Task ScrollToBottom()
    {
        try
        {
            await JS.InvokeVoidAsync("eval", "document.getElementById('chat-messages')?.scrollTo(0, document.getElementById('chat-messages').scrollHeight)");
        }
        catch
        {
            // Ignore JS errors
        }
    }
    
    private string GetFileIcon(string contentType) => contentType switch
    {
        var ct when ct.Contains("pdf") => Icons.Material.Filled.PictureAsPdf,
        var ct when ct.Contains("image") => Icons.Material.Filled.Image,
        var ct when ct.Contains("word") || ct.Contains("doc") => Icons.Material.Filled.Description,
        var ct when ct.Contains("text") => Icons.Material.Filled.TextSnippet,
        var ct when ct.Contains("spreadsheet") || ct.Contains("excel") => Icons.Material.Filled.TableChart,
        _ => Icons.Material.Filled.InsertDriveFile
    };

    private string FormatFileSize(long bytes)
    {
        if (bytes == 0) return "0 B";
        const int k = 1024;
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        var i = (int)Math.Floor(Math.Log(bytes) / Math.Log(k));
        return $"{bytes / Math.Pow(k, i):0.##} {sizes[i]}";
    }

    public void Dispose()
        => currentResponseCancellation?.Cancel();
        
    private class FileAttachment
    {
        public string Name { get; set; } = "";
        public long Size { get; set; }
        public string ContentType { get; set; } = "";
        public required IBrowserFile BrowserFile { get; set; }
    }

}